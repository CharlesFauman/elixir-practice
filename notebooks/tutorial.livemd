# Tutorial

## Main

Following https://elixir-lang.org/getting-started/basic-types.html

## Anonymous Functions

```elixir
add = fn a, b -> a + b end
```

```elixir
add.(1, 2)
```

```elixir
is_function(add)
```

```elixir
double = fn a -> add.(a, a) end
```

```elixir
double.(2)
```

```elixir
:a < :b
```

## Pattern matching

https://elixir-lang.org/getting-started/pattern-matching.html

```elixir
x = 1
1 = x
```

```elixir
1 = unknown
```

```elixir
unknown = 1
```

```elixir
1 = unknown
```

```elixir
{a, b, c} = {:hello, "world", 42}
```

```elixir
a
```

```elixir
[head | tail] = [1, 2, 3]

IO.puts(head)
tail
```

```elixir
[head | tail] = []
```

```elixir
[4 | [0 | [1, 2, 3]]]
```

```elixir
x = 1
1 = x
x = 2
2 = x
^x = 3
```

```elixir
[head | _] = [1, 2, 3]
head
```

```elixir
length([1, 2]) = 2
```

## case, cond, and if

https://elixir-lang.org/getting-started/case-cond-and-if.html

```elixir
case {1, 2, 3} do
  {4, 5, 6} ->
    "no match"

  {1, x, 3} ->
    "match, x is bound"

  _ ->
    "match"
end
```

```elixir
x = 1

case 2 do
  ^x -> "won't match"
  _ when false -> "won't match"
  _ -> "match"
end
```

```elixir
f = fn
  x, y when x > 0 -> x + y
  x, y -> x * y
end

IO.puts(f.(1, 3))
IO.puts(f.(-1, 3))
```

```elixir
cond do
  2 + 2 == 5 -> "nope"
  :error -> "yes!"
end
```

```elixir
cond do
  nil -> "nope"
end
```

```elixir
if true do
  "if success"
end
```

```elixir
unless false do
  "unless triggered"
end
```

```elixir
if false do
  "nope"
else
  "yes"
end
```

```elixir
x = 1

if true do
  x = x + 1
end
```

```elixir
x
```

```elixir
x =
  if true do
    x + 1
  end
```

```elixir
x
```

```elixir

```

## Binaries, strings, and charlists

```elixir
?h
```

```elixir
"\u0061" == "a"
```

```elixir
"\u0061"
```

```elixir
"\u1D4B6"
```
